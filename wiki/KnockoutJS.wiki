#summary KnockoutJS template security and XSS

<wiki:toc max_depth="2" />

= Introduction =

"Knockout is a standalone JavaScript implementation of the Model-View-!ViewModel pattern with templates. The underlying principles are therefore:

 * a clear separation between domain data, view components and data to be displayed
 * the presence of a clearly defined layer of specialized code to manage the relationships between the view components

The latter leverages the native event management features of the Javascript language.

These features streamline and simplify the specification of complex relationships between view components, which in turn make the display more responsive and the user experience richer.

Knockout was developed and is maintained by Steve Sanderson, a Microsoft employee. The author stresses that this is a personal open-source project, and not a Microsoft product"

From http://en.wikipedia.org/wiki/KnockoutJS

= Quick Facts =

 * [http://knockoutjs.com/downloads/knockout-3.0.0.debug.js KnockoutJS 3.0.0 (Uncompressed)]
 * Usage Stats http://trends.builtwith.com/javascript/KnockoutJS


 * *{}SEC-A* <font color="red">*FAIL*</font> Template expressions are equivalent to `eval`
 * *{}SEC-B* <font color="red">*FAIL*</font> No sandbox or isolated execution scope
 * *{}SEC-C* <font color="red">*FAIL*</font> !JavaScript code will be executed from within `data` attributes
 * *{}SEC-D* <font color="red">*FAIL*</font> No enforced separation, no obvious way to outsource templates to static files
 * *{}SEC-E* <font color="red">*FAIL*</font> No dedicated security response program, no security@knockoutjs.com address

= Injection Attacks =

== KnockoutJS 2.3.0 ==

KnockoutJS is attackers best friend since it allows to execute arbitrary !JavaScript by injecting into HTML5 data attributes. Any labelled !JavaScript code that is being found inside a `data-bind` attribute will be evaluated once the bindings are being applied by KnockoutJS.

The following "paste-and-go"-ready code example demonstrates that. 

{{{
<script src="http://knockoutjs.com/downloads/knockout-2.3.0.js"></script>
<div data-bind="x:alert(1)" />
<script> 
	ko.applyBindings();
</script>
}}}

== KnockoutJS 3.0.0 ==

Not much has changed - only the example above doesn't work any more. Well, with some quick changes applied we can get our `alert` back and do the same as we did before. In essence, the label of our binding must match a binding provided by KnockoutJS - and there's quite a bunch of them.  

{{{
<script src="http://knockoutjs.com/downloads/knockout-3.0.0.js"></script>
<div data-bind="click: alert(1)"></div>
<div data-bind="value: alert(2)"></div>
<div data-bind="style: alert(3)"></div>
...
<select data-bind="options: alert(99)"></select>
<script> 
ko.applyBindings();
</script>
}}}

== Eval via Function ==

As can be seen, very much like CanJS, KnockoutJS uses a string containing a `with()` block to wrap the template data and then send it to the `Function` constructor for direct string-to-code.

{{{
parseBindingsString: function(b, c, d) {
    try {
        var f;
        if (!(f = this.Na[b])) {
            var g = this.Na, e, m = "with($context){with($data||{}){return{" + a.g.ea(b) + "}}}";
            e = new Function("$context", "$element", m);
            f = g[b] = e
        }
        return f(c, d)
    } catch (h) {
        throw h.message = "Unable to parse bindings.\nBindings value: " + b + "\nMessage: " + h.message, h;
    }
}
}}}

In KnockoutJS 3.0.0 - the example above shows code from 2.3.0 - things have changed a little bit. The way our code is being executed is still the same though: the value of `data-bind` is being parsed and parts of it are passed to the function constructor. 

{{{
    function createBindingsStringEvaluator(bindingsString, options) {
        // Build the source for a function that evaluates "expression"
        // For each scope variable, add an extra level of "with" nesting
        // Example result: with(sc1) { with(sc0) { return (expression) } }
        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),
            functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
        return new Function("$context", "$element", functionBody);
    }
}}}